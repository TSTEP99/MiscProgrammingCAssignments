.ORIG x3000

AND R6,R6,#0
ADD R6,R6,#-1

INPUT_KEYBOARD GETC
OUT

LD R1, OPEN_BRACKET ;Check if open brakcet
ADD R7,R0,R1
BRz PUSH_2_STACK

LD R1, CLOSING_BRACKET ;check if closing bracket
ADD R7,R0,R1
BRz CHECK_BRACKETS

LD R1, SPACE ;check if space
ADD R7,R0,R1
BRz INPUT_KEYBOARD

ADD R7, R0,#-10
BRz IS_EMPTY

PUSH_2_STACK JSR PUSH
BRnzp INPUT_KEYBOARD

CHECK_BRACKETS JSR POP
LD R1, OPEN_BRACKET
ADD R7,R0,R1
BRnp STOP
BRz INPUT_KEYBOARD

IS_EMPTY JSR POP
ADD R5,R5,#0
BRz STOP
ADD R6,R6,#2
BRnzp STOP



STOP HALT

OPEN_BRACKET .FILL #-40
CLOSING_BRACKET .FILL #-41
SPACE .FILL #-32

;IN:R0, OUT:R5 (0-success, 1-fail/overflow)
;R3: STACK_END R4: STACK_TOP
;
PUSH	
	ST R3, PUSH_SaveR3	;save R3
	ST R4, PUSH_SaveR4	;save R4
	AND R5, R5, #0		;
	LD R3, STACK_END	;
	LD R4, STACK_TOP	;
	ADD R3, R3, #-1		;
	NOT R3, R3		;
	ADD R3, R3, #1		;
	ADD R3, R3, R4		;
	BRz OVERFLOW		;stack is full
	STR R0, R4, #0		;no overflow, store value in the stack
	ADD R4, R4, #-1		;move top of the stack
	ST R4, STACK_TOP	;store top of stack pointer
	BRnzp DONE_PUSH		;
OVERFLOW
	ADD R5, R5, #1		;
DONE_PUSH
	LD R3, PUSH_SaveR3	;
	LD R4, PUSH_SaveR4	;
	RET


PUSH_SaveR3	.BLKW #1	;
PUSH_SaveR4	.BLKW #1	;


;OUT: R0, OUT R5 (0-success, 1-fail/underflow)
;R3 STACK_START R4 STACK_TOP
;
POP	
	ST R3, POP_SaveR3	;save R3
	ST R4, POP_SaveR4	;save R3
	AND R5, R5, #0		;clear R5
	LD R3, STACK_START	;
	LD R4, STACK_TOP	;
	NOT R3, R3		;
	ADD R3, R3, #1		;
	ADD R3, R3, R4		;
	BRz UNDERFLOW		;
	ADD R4, R4, #1		;
	LDR R0, R4, #0		;
	ST R4, STACK_TOP	;
	BRnzp DONE_POP		;
UNDERFLOW
	ADD R5, R5, #1		;
DONE_POP
	LD R3, POP_SaveR3	;
	LD R4, POP_SaveR4	;
	RET


POP_SaveR3	.BLKW #1	;
POP_SaveR4	.BLKW #1	;
STACK_END	.FILL x3FF0	;
STACK_START	.FILL x4000	;
STACK_TOP	.FILL x4000	;



.END